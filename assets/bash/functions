#!/usr/bin/env bash

# Repo dir.

function repo_dir() {
  local file;
  local dir;
  file="${BASH_SOURCE[0]}";
  dir="$(dirname "${file}")";
  dir="$(dirname "${dir}")";
  dir="$(dirname "${dir}")";
  echo "${dir}";
};

# Is vagrant?

function is_vagrant() {
  if id --user vagrant &>/dev/null; then
    return 0;
  elif [[ -d "$(repo_dir)"/.vagrant ]]; then
    return 0;
  else # 1 = false.
    return 1;
  fi;
};

# Trim.

function trim() {
  if [[ -p /dev/stdin ]]; then
    echo -n "$(perl -wpe 's/(^\s+|\s+\$)//ug')";
  else
    echo -n "$(echo "${1}" | perl -wpe 's/(^\s+|\s+\$)//ug')";
  fi;
};

# Calculate RAM (in MB) divided by X.

function ram_mb_divided_by() {
  divisor="${1:-3}"; # Defaults to `3` (33%).
  echo "$(free -m | grep --perl-regexp 'Mem\:' | awk '{print int($2/'"${divisor}"')}')";
};

# Random key generator.

function keygen() {
  cat /dev/urandom | tr -dc "${2:-a-zA-Z0-9}" | fold -w ${1:-64} | head -n 1 || true;
};

# Check if a command exists.

function can_run() {
  command -v "${1}" >/dev/null 2>&1;
};

# Escape regex.

function esc_regex() {
  echo "$(echo "${1:-}" | perl -wpe 's/([.\\+*?[\^\]$(){}=!<>|:\-])/\\$1/ug')";
};

# Escape regex replacement value.

function esc_regex_rv() {
  local rv="${1:-}";
  rv="${rv/@/\\@}";
  rv="${rv/$/\\$}";
  echo "${rv}";
};

# Count occurrences of string.

function dot_count() {
  grep --perl-regexp --only-matching '\.' <<< "${1:-}" | wc --lines;
};

# Remove duplicates from a space-separated list.

function dedupe_list() {
  echo "${1:-}" | xargs -n1 | sort -u | xargs;
};

# Does a user exist?

function user_exists() {
  id -u "${1:-}" &>/dev/null;
};

# Is a user in a specific group?

function user_in_group() {
  id --name --groups "${1:-}" | grep --perl-regexp --quiet "\b${2:-}\b";
};

# New user creation utility.

function create_user() {
  local user="${1:-}";
  local pass="${2:-}";
  local group="${3:-}";

  if [[ -z "${user}" || -z "${pass}" || -z "${group}" ]]; then
    return 1; fi; # Missing required arg(s).

  if user_exists "${user}"; then
    return 1; fi; # User exists!

  useradd "${user}" --gid "${group}" --create-home;
  echo "${user}"':'"${pass}" | chpasswd;
};

# User setup/configuration utility.

function setup_user() {
  local user="${1:-}";
  local name="${2:-}";
  local email="${3:-}";
  local shell="${4:-}";
  local ssh_keys="${5:-}";

  ## Validation.

  if [[ -z "${user}" ]]; then
    return 1; fi; # Missing.

  if ! user_exists "${user}"; then
    return 1; fi; # Missing.

  ## Determine home directory.

  if [[ "${user}" == root ]]; then
    local home_dir=/root; # Special case.
  else local home_dir=/home/"${user}"; fi;

  if [[ ! -d "${home_dir}" ]]; then
    return 1; fi; # Missing home dir.

  ## Set the login shell they prefer to use.

  if [[ -n "${shell}" ]]; then
    chsh --shell "${shell}" "${user}"; fi;

  ## Home directory customization.

  cp --force --recursive --preserve=mode /bootstrap/assets/tpl.home/. "${home_dir}";
  chown --recursive "${user}" "${home_dir}";

  ## Setup authorized SSH keys in home directory.

  if [[ -f "${ssh_keys}" ]]; then
    mkdir --parents "${home_dir}"/.ssh;
    cp --force "${ssh_keys}" "${home_dir}"/.ssh/authorized_keys;

    chmod 700 "${home_dir}"/.ssh;
    chmod 600 "${home_dir}"/.ssh/authorized_keys;
    chown --recursive "${user}" "${home_dir}"/.ssh;
  fi;
  ## Git configuration for this user.

  perl -i -wpe 's/^(\s*)name\s*\=.*$/$1name = '"$(esc_regex_rv "${name}")"'/uim' "${home_dir}"/.gitconfig;
  perl -i -wpe 's/^(\s*)email\s*\=.*$/$1email = '"$(esc_regex_rv "${email}")"'/uim' "${home_dir}"/.gitconfig;
};

# Enable maintenance mode.

function enable_app_maintenance_mode() {
  touch /app/.~maintenance;
};

# Disable maintenance mode.

function disable_app_maintenance_mode() {
  rm --force /app/.~maintenance;
  can_run cachetool && cachetool opcache:reset;
  return 0; # In case last test fails.
};

# Auto-disable maintenance mode on error.

function auto_disable_app_maintenance_mode_on_error() {
  disable_app_maintenance_mode; stack_trace "$@";
}; # e.g., `trap auto_disable_app_maintenance_mode_on_error ERR;`

# Adds a new global environment variable.

function add_global_env_var() {
  local key="${1:-}";
  local value="${2:-}";

  if [[ -z "${key}" ]]; then
    return 1; fi; # Must have.

  ## System-wide; including CRON jobs.

  echo "${key}='${value}'" >> /etc/environment;

  ## Adds PHP-FPM environment variables.

  if [[ "${value}" == '' ]]; then # FPM chokes on empty strings.
   # Single spaces are handled by /bootstrap/assets/php/ap.php automatically.
    echo "env[${key}] = ' '" >> /etc/php/fpm/env.conf; # Use a single space.
  else echo "env[${key}] = '${value}'" >> /etc/php/fpm/env.conf; fi;

  ## Adds environment variables for Apache also.

  if [[ -f /etc/apache2/envvars ]]; then
    echo "export ${key}='${value}'" >> /etc/apache2/envvars;
  else # Adds a file that our Apache installer can read from.
    echo "export ${key}='${value}'" >> /etc/apache2/~envvars;
  fi;
  ## Keep these environment variables when running `sudo`.
  ## Note that double quotes are required here.

  echo "Defaults env_keep += \"${key}\"" >> /etc/sudoers.d/env-vars;
};
